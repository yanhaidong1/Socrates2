## sample ##
##updating 011425 this is only for the upsampling 
##updating 080922 if there is no batch we need to use design <- model.matrix(~ group) other than design <- model.matrix(~ 0 + group)
##becareful about the batch we are setting sample.data$tissue <- gsub('\\..+','',sample.data[,2])
##this is only useful for the rice data since the cluster has 

##updating 080322 we will set an option to open or close the batch effect generated by rice case
##updating 070322 we will use the upsampling to calculate the FC
##updating 060722 we will use the bg file to calculate the DEGs
##updating 060222 try to normalize the pb
##updating 060122 we will update the script to allow us to use the cell type as the group other than the organs
##updating 031122 this is for the ori meta version
##do the upsampling and call DAR
##keep in mind the target cluster is LouvainClusters_final




# load libraries
library(SingleCellExperiment)
library(Matrix)
library(Matrix.utils)
library(edgeR)
library(parallel)


args <- commandArgs(trailingOnly=T)

counts_acr_threcol_sprase_fl <- as.character(args[1])
##/scratch/hy17471/soybean_scATAC_100120/pipeline_analysis_110220/08_3_re_make_peak_matrices_byremove_blackregions_020321/02_generate_final_peak_sparse_120921/output_dir/opt_peak_rmblack.sparse

metadata <- as.character(args[2]) ##meta file
##/scratch/hy17471/soybean_scATAC_100120/pipeline_analysis_110220/add_07_DA_peak_res01_shift_subc_comb_newpeak_040621_modelway_cons_geno_25clustVer_120921/opt_final_meta_30050_rmblack_chUMAParEN_rmWill_addfinalcolr_comb.txt

output_dir <- as.character(args[3]) ##

#thread_num <- as.numeric(args[4]) 

#target_cluster <- as.character(args[5]) ##LouvainClusters_final

#select_method <- as.character(args[6]) ##read or cell

input_config_file <- as.character(args[4])

open_rm_batch_organs <- 'no' ##yes or no
##if it is yes, we would remove by adding a tissue but only is suitable for rice
##if it is no, we do not want to remove batch by the organs

##counts_acr_threcol_sprase_fl <- '/scratch/hy17471/soybean_scATAC_100120/pipeline_analysis_110220/08_3_re_make_peak_matrices_byremove_blackregions_020321/02_generate_final_peak_sparse_120921/output_dir/opt_peak_rmblack.sparse'
##metadata = '/scratch/hy17471/soybean_scATAC_100120/pipeline_analysis_110220/add_07_DA_peak_res01_shift_subc_comb_newpeak_040621_modelway_cons_geno_25clustVer_120921/opt_final_meta_30050_rmblack_chUMAParEN_rmWill_addfinalcolr_comb.txt'

source(input_config_file)

upsample <- function(cnts, meta){
  
  # get number of cells per cluster
  clust.cnts <- table(meta[[target_cluster]])
  most <- max(clust.cnts)
  new.ids <- lapply(unique(meta[[target_cluster]]), function(x){
    df <- subset(meta, meta[[target_cluster]]==x)
    if(nrow(df)<most){
      dif <- most - nrow(df) 
      add <- rownames(df)[sample(nrow(df),dif,replace=T)]
      ids <- sort(c(rownames(df),add))
      return(ids)
    }else{
      return(rownames(df))
    }
  })
  new.ids <- do.call(c, new.ids)
  meta <- meta[new.ids,]
  cnts <- cnts[,new.ids]
  colnames(cnts) <- rownames(meta)
  return(list(metadata=meta, counts=cnts))
  
}
downsample <- function(cnts, meta, num.cells=500){
  
  # get number of cells per cluster
  clust.cnts <- table(meta[[target_cluster]])
  most <- num.cells
  new.ids <- lapply(unique(meta[[target_cluster]]), function(x){
    df <- subset(meta, meta[[target_cluster]]==x)
    if(nrow(df) < most){
      dif <- most - nrow(df) 
      add <- rownames(df)[sample(nrow(df),dif,replace=T)]
      ids <- sort(c(rownames(df),add))
      return(ids)
    }else if(nrow(df) > most){
      ids <- sample(rownames(df), most, replace=F)
    }else{
      return(rownames(df))
    }
  })
  new.ids <- do.call(c, new.ids)
  meta <- meta[new.ids,]
  cnts <- cnts[,new.ids]
  colnames(cnts) <- rownames(meta)
  return(list(metadata=meta, counts=cnts))
}

##sample reads
sampleLib <- function(cnts, meta, read.counts=5e7, tol=0.01){
  
  # get number of cells per cluster
  meta$gene_cnt_totals <- Matrix::colSums(cnts)
  
  ##updating 011525
  ##allow the target cluster to be variable
  formula_str <- as.formula(paste("gene_cnt_totals~",target_cluster))
  clust.cnt <- aggregate(formula_str,data=meta, FUN=sum)
  
  #clust.cnt <- aggregate(gene_cnt_totals~Final_annotation_TCP, data=meta, FUN=sum)
  clust.cnts <- clust.cnt[,2]
  names(clust.cnts) <- clust.cnt[,1]
  if(read.counts=="max"){
    most <- max(clust.cnts)
  }else{
    most <- read.counts
  }
  accept.range <- c((most-(most*tol)),(most+(most*tol)))
  new.ids <- lapply(unique(meta[[target_cluster]]), function(x){
    message(" - scaling library sizes for cluster ",x," ...")
    df <- subset(meta, meta[[target_cluster]]==x)
    c.total <- sum(df$gene_cnt_totals)
    r.total <- c.total
    if(c.total < accept.range[1]){
      new.ids <- c(rownames(df))
      fin <- T
      its <- 0
      while(fin){
        its <- its + 1
        message("   * sampling iteration ", its)
        df.r <- df[sample(nrow(df)),]
        df.r.total <- sum(df.r$gene_cnt_totals)
        new.total <- r.total + df.r.total
        if(new.total < accept.range[1]){
          r.total <- new.total
          new.ids <- c(new.ids, rownames(df.r))
        }else if(new.total > accept.range[1] & new.total < accept.range[2]){
          r.total <- new.total
          new.ids <- c(new.ids, rownames(df.r))
          fin <- F
        }else{
          r.sums <- cumsum(df.r$gene_cnt_totals)
          dif.sums <- (r.sums + r.total) - accept.range[1]
          cell.idx <- min(which(dif.sums > 0))
          new.ids <- c(new.ids,rownames(df.r)[1:cell.idx])
          fin <- F
        }
      }
      ids <- new.ids
      return(ids)
    }else if(c.total > accept.range[2]){
      
      # randomize rows
      df.r <- df[sample(nrow(df)),]
      r.sums <- cumsum(df.r$gene_cnt_totals)
      dif.sums <- r.sums - accept.range[1]
      cell.idx <- min(which(dif.sums > 0))
      new.ids <- rownames(df.r)[1:cell.idx]
      return(new.ids)
      
    }else{
      return(rownames(df))
    }
  })
  new.ids <- do.call(c, new.ids)
  meta <- meta[new.ids,]
  cnts <- cnts[,new.ids]
  colnames(cnts) <- rownames(meta)
  return(list(metadata=meta, counts=cnts))
  
}



# functions
edgeRscDEG <- function(sce,open_rm_batch_organs, ids=c("LouvainClusters", "library"), threads=1, use.ref.cells=F){
  
  # set up vars
  groups <- colData(sce)[, ids]
  ##
  #> groups
  #DataFrame with 111909 rows and 2 columns
  #Final_annotation_TCP     library
  #<character> <character>
  #  CB:Z:AAACGAAAGACACTTC-Eseed4                Eseed.AL      Eseed4
  #CB:Z:AAACGAAAGCCATTCA-Eseed3                Eseed.SA      Eseed3
  #CB:Z:AAACGAAAGCGTGTTT-Eseed4     Eseed.Eseed_unknown      Eseed4
  #CB:Z:AAACGAAAGTTTACGC-Eseed4                Eseed.AL      Eseed4
  #CB:Z:AAACGAACAAGAGATT-Eseed4        Eseed.Coleoptile      Eseed4
  #...                                              ...         ...
  #CB:Z:TTTGTGTTCGTGAGTT-semroot6    semroot.Endodermis    semroot6
  #CB:Z:TTTGTGTTCTCGCGTT-semroot6 semroot.SteleInitials    semroot6
  
  
  groups[,1] <- as.factor(groups[,1])
  ##131 Levels: bud.AbLeafPrimordia bud.AM bud.bud_unknown ... semroot.Trichoblast
  
  groups[,2] <- as.factor(groups[,2])
  ##18 Levels: bud1 bud2 crownroot4 crownroot5 Eseed3 Eseed4 ... semroot7
  
  clusters <- levels(groups[,1])
  ##> clusters
  #[1] "bud.AbLeafPrimordia"            "bud.AM"
  #[3] "bud.bud_unknown"                "bud.BundleSheath"
  #[5] "bud.Mesophyll"                  "bud.Phloem"
  #[7] "bud.PhloemSievePrecursor"       "bud.ProcambialMeristem"
  
  threads <- ifelse(length(clusters) > threads, threads, length(clusters))
  
  # set-up reference cells
  if(use.ref.cells){
    cells.per.cluster <- ceiling(mean(table(colData(sce)[,ids[1]])))
    cells.per.group <- ceiling(cells.per.cluster/length(clusters))
    ran.cells <- unlist(lapply(clusters, function(x){
      sample(rownames(colData(sce)), cells.per.group)
    }))
    message(" - reference pseudobulk sample contains ", length(ran.cells), " cells ...")
  }
  
  # iterate
  outs <- mclapply(clusters, function(z){
    
    # verbose
    message(" - identifying DEG from cluster ", z)
    
    # rename groups
    df <- as.data.frame(groups)
    df[,1] <- as.character(df[,1])
    ##allow the target cluster to be 1 and all the others to be 0
    ##it is clear now since we compared target to all the others
    ##so there are two groups here
    df$cluster_id <- as.factor(ifelse(df[,1] == z, 1, 0))
    ##allow the previous cluster to be NULL
    ##we will not use this one
    #df[,1] <- NULL
    if(use.ref.cells){
      df <- df[ifelse(df$cluster_id==1 | rownames(df) %in% ran.cells, T, F),]
    }
    ##return total number of gene/ACR for each cell
    ##since it is the binary mtx for the counts(sce)
    n.genes <- Matrix::colSums(counts(sce)[,rownames(df)] > 0)
    ##> head(n.genes)
    ##CB:Z:AAACGAAAGACACTTC-Eseed4 CB:Z:AAACGAAAGCCATTCA-Eseed3
    #828                         2071
    #CB:Z:AAACGAAAGCGTGTTT-Eseed4 CB:Z:AAACGAAAGTTTACGC-Eseed4
    #896                          749
    #CB:Z:AAACGAACAAGAGATT-Eseed4 CB:Z:AAACGAACAAGTTGCT-Eseed4
    #1667                         1007
    
    ##n.genes corresponds to a vector that contains the cell name and its gene number
    ##df$cluster_id indicates the cluster of cell name
    ##df[,ids[2]] indicates the library of cell name
    ##so in this case, we will calculate the average number of genes for each cluster for each library
    ##like
    ##cluster lib avg.genenum
    ##1       rep1    40.3
    ##1       rep2    30.5
    ##0       rep1    40.1
    ##0       rep2    30.8
    ##so in this case 0 means the other cluster information
    
    #######
    ##debug updating 060122 we need to generate a new ID that should be same as the pb row name
    ##generate a new column
    df$newID <- paste(sep = '_',df[,1],df[,2],df[,3])
    #df$newID <- paste(sep = '_',df$Final_annotation_TCP,df$library,df$cluster_id)
    sample.data <- aggregate(n.genes~df$cluster_id+df$newID + df$library, FUN=mean)
    ##add the organ information
    ##this is suitable for the rice case because we would use the bud.1 bud.2 to show the different libraray 
    ##after modification of this string, we would obtain the bud
    
    ##udpating 011525 we will not generate the tissue column
    #sample.data$tissue <- gsub('\\..+','',sample.data[,2])
    
    
    
    #sample.data <- aggregate(n.genes~df$cluster_id+df[,ids[2]], FUN=mean)
    #> sample.data
    #df$cluster_id                                    df$newID   n.genes
    #1               1                  bud.AbLeafPrimordia_bud1_1 1521.0475
    #2               1                  bud.AbLeafPrimordia_bud2_1 2052.0699
    #3               0                               bud.AM_bud1_0 1612.7957
    #4               0                               bud.AM_bud2_0 2171.7307
    #5               0                      bud.bud_unknown_bud1_0 1548.1615
    #6               0                      bud.bud_unknown_bud2_0 2050.9631
    #7               0                     bud.BundleSheath_bud1_0 1746.5947
    
    
    ##order the cluster
    ##we may not sort the id
    ##other wise the 1 1 will not match to the final file
    #sample.data <- sample.data[order(sample.data[,1], decreasing=F),]
    
    # aggregate by cluster/library
    groupings_df <- df[,1:3]
    pb <- aggregate.Matrix(t(counts(sce)[,rownames(df)]), 
                           groupings = groupings_df, fun = "sum")
    
    #> head(df)
    #Final_annotation_TCP library cluster_id
    #CB:Z:AAACGAAAGACACTTC-Eseed4             Eseed.AL  Eseed4          0
    #CB:Z:AAACGAAAGCCATTCA-Eseed3             Eseed.SA  Eseed3          0
    #CB:Z:AAACGAAAGCGTGTTT-Eseed4  Eseed.Eseed_unknown  Eseed4          0
    #CB:Z:AAACGAAAGTTTACGC-Eseed4             Eseed.AL  Eseed4          0
    
    ##the aggregate function will bud.AbLeafPrimordia_bud1_1
    
    ##use the groupings
    ##it will connect all the column together 
    pb <- t(pb)
    #> pb[1:5,1:5]
    #5 x 5 sparse Matrix of class "dgCMatrix"
    #bud.AbLeafPrimordia_bud1_1 bud.AbLeafPrimordia_bud2_1
    #Chr1_10002117_10002618                        146                         93
    #Chr1_10002726_10003227                          .                          .
    #Chr1_10003448_10003949                        323                        215
    #Chr1_10005481_10005982                          .                          .
    #Chr1_10006162_10006663                         18                         12
    #bud.AM_bud1_0 bud.AM_bud2_0 bud.bud_unknown_bud1_0
    #Chr1_10002117_10002618           157           100                     61
    #Chr1_10002726_10003227             .             .                      .
    #Chr1_10003448_10003949           262           176                    107
    #Chr1_10005481_10005982             .             .                      .
    #Chr1_10006162_10006663            14            14                      3
    

  
    #colnames(sample.data) <- c("cluster_id",ids[1], "n.genes",'tissue')
    colnames(sample.data) <- c("cluster_id",ids[1],"library", "n.genes")
    
    ##head(sample.data)
    ##  cluster_id       Final_annotation_TCP  n.genes
    #1          1 bud.AbLeafPrimordia_bud1_1 1521.047
    #2          1 bud.AbLeafPrimordia_bud2_1 2052.070
    #3          0              bud.AM_bud1_0 1612.796
    #4          0              bud.AM_bud2_0 2171.731
    #5          0     bud.bud_unknown_bud1_0 1548.161
    #6          0     bud.bud_unknown_bud2_0 2050.963
    
    
    
    # create edgeR object
    group <- factor(sample.data$cluster_id, levels=c(0,1))
    batch <- factor(sample.data[,ids[2]])
    #batch <- factor(sample.data[,'tissue'])
    ave.genes <- scale(sample.data$n.genes)
    dge <- DGEList(counts = pb, 
                   norm.factors = rep(1, length(pb[1,])), 
                   group = group)
    
    ##the main idea is to create a batch that means the library

    # design experiment and estimate norm factors/dispersion
    ##batch would be library since we have two libraries we can do the comparision
    if (open_rm_batch_organs == 'no'){
      design <- model.matrix(~ 0 + batch + group)
    }else{
      ##updating 080922
      design <- model.matrix(~ group)
    }
    dge <- calcNormFactors(dge, method = "TMM", refColumn=2, logratioTrim=0.1)
    dge <- estimateDisp(dge, design = design)
    
    # estimate Differential expression
    fit <- glmQLFit(dge, design)
    res <- glmQLFTest(fit, coef=ncol(fit$coefficients))
    res$table$FDR <- p.adjust(res$table[,4], method="fdr")
    res$table$cluster_id <- z
    res$table$geneID <- rownames(res$table)
    rownames(res$table) <- seq(1:nrow(res$table))
    message("   ~ returning results for cluster ",z)
    return(res$table)
    
  }, mc.cores=threads)
  outs <- do.call(rbind, outs)
  return(outs)
  
}

##updating 060722
##calculate the DEGs by ourselves
# functions
calFC <- function(sce, ids=c("LouvainClusters", "library"), threads=1, use.ref.cells=F){
  
  # set up vars
  groups <- colData(sce)[, ids]

  groups[,1] <- as.factor(groups[,1])
  ##131 Levels: bud.AbLeafPrimordia bud.AM bud.bud_unknown ... semroot.Trichoblast
  
  groups[,2] <- as.factor(groups[,2])
  ##18 Levels: bud1 bud2 crownroot4 crownroot5 Eseed3 Eseed4 ... semroot7
  
  clusters <- levels(groups[,1])
  
  threads <- ifelse(length(clusters) > threads, threads, length(clusters))
  
  # set-up reference cells
  if(use.ref.cells){
    cells.per.cluster <- ceiling(mean(table(colData(sce)[,ids[1]])))
    cells.per.group <- ceiling(cells.per.cluster/length(clusters))
    ran.cells <- unlist(lapply(clusters, function(x){
      sample(rownames(colData(sce)), cells.per.group)
    }))
    message(" - reference pseudobulk sample contains ", length(ran.cells), " cells ...")
  }
  
  # iterate
  outs <- mclapply(clusters, function(z){
    
    # verbose
    message(" - identifying DEG from cluster ", z)
    
    # rename groups
    df <- as.data.frame(groups)
    df[,1] <- as.character(df[,1])
    ##allow the target cluster to be 1 and all the others to be 0
    ##it is clear now since we compared target to all the others
    ##so there are two groups here
    df$cluster_id <- as.factor(ifelse(df[,1] == z, 1, 0))
    ##allow the previous cluster to be NULL
    ##we will not use this one
    #df[,1] <- NULL
    if(use.ref.cells){
      df <- df[ifelse(df$cluster_id==1 | rownames(df) %in% ran.cells, T, F),]
    }
    ##return total number of gene/ACR for each cell
    ##since it is the binary mtx for the counts(sce)
    n.genes <- Matrix::colSums(counts(sce)[,rownames(df)] > 0)
    ##> head(n.genes)
    
    #######
    ##debug updating 060122 we need to generate a new ID that should be same as the pb row name
    ##generate a new column
    df$newID <- paste(sep = '_',df[,1],df[,2],df[,3])
    #df$newID <- paste(sep = '_',df$Final_annotation_TCP,df$library,df$cluster_id)
    sample.data <- aggregate(n.genes~df$cluster_id+df$newID, FUN=mean)
    ##add the organ information
    sample.data$tissue <- gsub('\\..+','',sample.data[,2])
    
    ##order the cluster
    ##we may not sort the id
    ##other wise the 1 1 will not match to the final file
    #sample.data <- sample.data[order(sample.data[,1], decreasing=F),]
    
    # aggregate by cluster/library
    groupings_df <- df[,1:3]
    pb <- aggregate.Matrix(t(counts(sce)[,rownames(df)]), 
                           groupings = groupings_df, fun = "sum")
    
    #> head(df)
    #Final_annotation_TCP library cluster_id
    #CB:Z:AAACGAAAGACACTTC-Eseed4             Eseed.AL  Eseed4          0
    #CB:Z:AAACGAAAGCCATTCA-Eseed3             Eseed.SA  Eseed3          0
    #CB:Z:AAACGAAAGCGTGTTT-Eseed4  Eseed.Eseed_unknown  Eseed4          0
    #CB:Z:AAACGAAAGTTTACGC-Eseed4             Eseed.AL  Eseed4          0
    
    ##the aggregate function will bud.AbLeafPrimordia_bud1_1
    
    ##use the groupings
    ##it will connect all the column together 
    pb <- t(pb)
    
    saveRDS(paste0(output_dir,'/opt_temp_pb.rds'))
    
    #################
    ##updating 060722
    ##we will normalize the tmp.pb and check the DEGs of target cell types
    tmp.pb <- t(t(pb)* 1e6 / colSums(pb)) 
    tmp.pb<-round(tmp.pb,0)
    
    saveRDS(paste0(output_dir,'/opt_temp_norm_pb.rds'))
    
    ##extract target id
    target_celltye_lib_id <- sample.data[sample.data[[1]]=='1',][,2]
    ##use the target id for the matrix
    target_celltype_tmp.pb <- tmp.pb[,target_celltye_lib_id]
    ##get average for the target celltype
    target_celltype_tmp.pb <- as.matrix(target_celltype_tmp.pb)
    rowmean_target_celltype <- rowMeans(target_celltype_tmp.pb)
    
    ##extract the other ids
    other_celltype_lib_id <- sample.data[sample.data[[1]] == '0',][,2]
    ##use the other ids for the matrix
    other_celltype_tmp.pb <- tmp.pb[,other_celltype_lib_id]
    ##get average for the other celltype
    rowmean_other_celltype <- rowMeans(other_celltype_tmp.pb)
    
    FC <- rowmean_target_celltype/rowmean_other_celltype
    FC <- as.data.frame(FC)
    FC$location <- rownames(FC)
    FC <- FC[FC$FC> 1,]
    FC$celltype <- z
  
    return(FC)

  }, mc.cores=threads)
  outs <- do.call(rbind, outs)
  return(outs)

}










message(" - loading data ...")
##check whether the count_mtx already exist
if (file.exists(paste0(output_dir,'/opt_count_mtx.rds'))){
  upsp_counts <- readRDS(paste0(output_dir,'/opt_count_mtx.rds'))
  upsp_metadata <- read.table(paste0(output_dir,'/opt_sampled_meta.txt'))
}else{

  ##counts is the matrix
  if (file.exists(paste0(output_dir,'/temp_all_sparse_mtx.rds'))){
    counts <- readRDS(paste0(output_dir,'/temp_all_sparse_mtx.rds'))
  }else{
    acr_sparse_dt <- read.table(counts_acr_threcol_sprase_fl,stringsAsFactors = T)
    activity <- sparseMatrix(i=as.numeric(acr_sparse_dt$V1),
                             j=as.numeric(acr_sparse_dt$V2),
                             x=as.numeric(acr_sparse_dt$V3),
                             dimnames=list(levels(acr_sparse_dt$V1), levels(acr_sparse_dt$V2)))
    atac_mtx <- as(activity, "dgCMatrix")
    saveRDS(atac_mtx,paste0(output_dir,'/temp_all_sparse_mtx.rds'))
    counts <- atac_mtx
  }
  
  metadata <- read.delim(metadata)
  rownames(metadata) <- metadata$cellID
  
  # process
  message(" - processing input objects ...")
  shared <- intersect(rownames(metadata), colnames(counts))
  metadata <- metadata[shared,]
  counts <- counts[,shared]
  counts <- counts[Matrix::rowSums(counts) > 0,]
  
  if (select_method == 'read') {
    upsampled <- sampleLib(counts, metadata)
  }else{
    upsampled <- upsample(counts, metadata)
  }
  
  saveRDS(upsampled$counts,paste0(output_dir,'/opt_count_mtx.rds'))
  write.table(upsampled$metadata,paste0(output_dir,'/opt_sampled_meta.txt'))
  
  upsp_counts <- upsampled$counts
  upsp_metadata <- upsampled$metadata
}

message(' - call DAR')
sce <- SingleCellExperiment(assays = list(counts = upsp_counts),
                            colData = upsp_metadata)
sce <- sce[rowSums(counts(sce) > 0) >= 0, ]

sce <- sce[rowMeans(counts(sce) > 0) > 0, ]

message(" - running DAR analysis by cluster with replicates ...")
##the library was considered as the batch that will be considered
##the different genotype will be the batch so we will remove 
##we will use the library other than genotype
deg <- edgeRscDEG(sce,open_rm_batch_organs, threads=thread_num, ids=c(target_cluster, "library"))
saveRDS(deg,paste0(output_dir,'/temp_deg.rds'))

deg <- deg[order(deg$cluster_id, deg$FDR, decreasing=F),]
write.table(deg, file=paste0(output_dir,'/',"DA_pseudobulk_deg.txt"), quote=F, row.names=T, sep="\t", col.names=T)

##updating 011425
sig <- subset(deg, deg$FDR < FDR_cutoff & deg$logFC > log2fc_cutoff)
#sig <- subset(deg, deg$FDR < 0.1 & deg$logFC > 0)
write.table(sig, file=paste0(output_dir,'/','opt_final_DA_pseudobulk.FDR',FDR_cutoff,'.log2fc',log2fc_cutoff,'.txt'), quote=F, row.names=T, col.names=T, sep="\t")

##write the FC 
#FCouts <- calFC(sce, threads=thread_num, ids=c(target_cluster, "library"))
##save the table
#write.table(FCouts,file=paste0(output_dir,'/','noupsamling_DA_pseudobulk_FC.txt'),quote = F, row.names = T, sep = '\t',col.names = T)

















